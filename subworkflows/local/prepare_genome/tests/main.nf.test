nextflow_workflow {

    name "Test Subworkflow PREPARE_GENOME"
    script "../main.nf"
    workflow "PREPARE_GENOME"

    tag "subworkflows"
    tag "subworkflows_local"

    test("only essentials") {
        when {
            workflow {
                """
                input[0] = []
                input[1] = []
                input[2] = []
                input[3] = []
                input[4] = []
                input[5] = []
                input[6] = params.pipelines_testdata_base_path + '/genomics/homo_sapiens/genome/genome.fasta'
                input[7] = []
                input[8] = []
                input[9] = params.pipelines_testdata_base_path + '/genomics/homo_sapiens/genome/genome.gtf'
                input[10] = []
                input[11] = []
                input[12] = []
                input[13] = "exon"
                input[14] = false
                input[15] = Channel.value(false)
                """
            }
        }

        then {
            assert workflow.success
            assertAll(
                { assert snapshot(
                    workflow.out.collectEntries { key, val ->
                        if(key.matches("\\d+")) {
                            return null
                        }
                        else if (val == [[]]) {
                            return null
                        }
                        else if(key == "star_index") {
                            return [key, val.collect { [it[0], path(it[1]).list().collect { file(it.toString()).name }] }]
                        }
                        return [key,val]
                    }.findAll { it != null }
                ).match() }
            )
        }
    }

    test("all") {
        when {
            workflow {
                """
                input[0] = params.modules_testdata_base_path + '/genomics/sarscov2/illumina/vcf/test2.vcf.gz'
                input[1] = []
                input[2] = params.modules_testdata_base_path + '/genomics/homo_sapiens/illumina/vcf/test.rnaseq.vcf'
                input[3] = []
                input[4] = params.pipelines_testdata_base_path + '/genomics/homo_sapiens/genome/genome.dict'
                input[5] = params.modules_testdata_base_path + '/genomics/homo_sapiens/genome/genome.bed'
                input[6] = params.pipelines_testdata_base_path + '/genomics/homo_sapiens/genome/genome.fasta'
                input[7] = params.pipelines_testdata_base_path + '/genomics/homo_sapiens/genome/genome.fasta.fai'
                input[8] = []
                input[9] = params.pipelines_testdata_base_path + '/genomics/homo_sapiens/genome/genome.gtf'
                input[10] = [
                    params.modules_testdata_base_path + '/genomics/homo_sapiens/illumina/vcf/test.rnaseq.vcf.gz',
                    params.modules_testdata_base_path + '/genomics/sarscov2/illumina/vcf/test2.vcf.gz'
                ]
                input[11] = []
                input[12] = params.pipelines_testdata_base_path + '/genomics/homo_sapiens/genome/index/star/star.tar.gz'
                input[13] = "exon"
                input[14] = false
                input[15] = Channel.value(true)
                """
            }
        }

        then {
            assert workflow.success
            assertAll(
                { assert snapshot(
                    workflow.out.collectEntries { key, val ->
                        if(key.matches("\\d+")) {
                            return null
                        }
                        else if (val == [[]]) {
                            return null
                        }
                        else if(key == "known_indels") {
                            return [key, val.sort { it.toString() }]
                        }
                        else if(key == "known_indels_tbi") {
                            return [key, val.sort { it.toString() }]
                        }
                        else if(key == "known_sites") {
                            return [key, val.sort { it.toString() }]
                        }
                        else if(key == "known_sites_tbi") {
                            return [key, val.sort { it.toString() }]
                        }
                        else if(key == "star_index") {
                            return [key, val.collect { [it[0], path(it[1]).list().collect { file(it.toString()).name }] }]
                        }
                        return [key,val]
                    }.findAll { it != null }
                ).match() }
            )
        }
    }
}
